<br>Javascript预编译和执行过程<br><br>1. 在执行前会进行类似“预编译”的操作：首先会创建一个当前执行环境下的活动对象，并将那些用<br>var申明的变量设置为活动对象的属性，但是此时这些变量的赋值都是undefined，并将那些以function<br>定义的函数也添加为活动对象的属性，而且它们的值正是函数的定义。<br>2.在解释执行阶段，遇到变量需要解析时，会首先从当前执行环境的活动对象中查找，如果没有找到而<br>且该执行环境的拥有者有prototype属性时则会从prototype链中查找，否则将会按照作用域链查找。遇<br>到var a = ...这样的语句时会给相应的变量进行赋值（注意：变量的赋值是在解释执行阶段完成的，如<br>果在这之前使用变量，它的值会是undefined）<br><br>用var定义的变量和function定义的方法在预编译的过程中有所不同，用代码来看看:<br>function mm(){ }<br>这种形式是声明一个函数，跟 var 一个变量的机制一样，脚本在解释执行之前会做预编译处理，而<br><br><br>var mm = function(){ }<br><br>这种形式是对一个变量赋值，虽然也做预编译，但仅仅只是给 mm 事先变量分配一个内存空间，而没有<br>做初始化<br><br><br>&lt;script type="text/javascript"&gt;<br><br>window.alert(mm);<br><br>function mm(){<br><br>}<br>&lt;/script&gt;<br>以上代码你会看到能alert出来mm的内容，但alert却是在function声明之前的，验证了脚本宿主在执行<br>之前对脚本做了预编译处理<br><br>&lt;script type="text/javascript"&gt;<br><br>window.alert(mm);<br><br>var mm = 123;<br><br>&lt;/script&gt;<br><br>以上代码你会看到alert出一个undefined来，说明脚本宿主在执行之前对脚本做了预编译：对mm分配内<br>存空间但并不初始化它<br><br><br>&lt;script type="text/javascript"&gt;<br><br>window.alert(nn);<br><br>window.alert(aa);<br><br>if(true){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function mm(){ }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var aa = 1;<br><br>}else{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function nn(){ }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var aa = 2;<br><br>}<br>&lt;/script&gt;<br><br>以上代码再次验证了预编译，并且说明预编译与条件无关。先弹出nn的函数定义，再弹出undefined。<br><br>上面3段代码比较容易理解，下面有些比较特殊点的<br>function myfunc(){<br>alert("hello");<br>}<br>myfunc();//这里调用myfunc，输出yeah而不是hello<br>function myfunc(){<br>alert("yeah");<br>}<br>myfunc();//这里调用myfunc，当然输出yeah<br>&nbsp;按理说，两个签名完全相同的函数，在其他编程语言中应该是非法的。但在JavaScript中，这没错。不<br>过，程序运行之后却发现一个奇怪的现象：两次调用都只是最后那个函数里输出的值！显然第一个函数<br>没有起到任何作用。这又是为什么呢？<br>&nbsp;&nbsp;&nbsp; 原来，JavaScript执行引擎并非一行一行地分析和执行程序，而是一段一段地分析执行的。而且，<br>在同一段程序的分析执行中，定义式的函数语句会被提取出来优先执行。函数定义执行完之后，才会按<br>顺序执行其他语句代码。也就是说，在第一次调用myfunc之前，第一个函数语句定义的代码逻辑，已被<br>第二个函数定义语句覆盖了。所以，两次都调用都是执行最后一个函数逻辑了。<br>如果把这个JavaScript代码分成两段，例如将它们写在一个html中，并用&lt;script/&gt;标签将其分成这样的<br>两块：<br>&lt;script&gt;<br>function myfunc(){<br>alert("hello");<br>}<br>myfunc();//这里调用myfunc，输出hello<br>&lt;/script&gt;<br><br>&lt;script&gt;<br>function myfunc(){<br>alert("yeah");<br>}<br>myfunc();//这里调用myfunc，输出yeah<br>&lt;/script&gt;<br>这时，输出才是各自按顺序来的，也证明了JavaScript的确是一段段地执行的。<br>上面是两个相同名字的function对象，如果是一个变量和一个function对象拥有相同的名字是什么情况<br>呢？<br>&lt;script type="text/javascript"&gt;<br>/*在预编译过程中func是window环境下的活动对象中的一个属性，值是一个函数，覆盖了undefined值*/<br>alert(func); //function func<br>var func = "this is a variable"<br>function func(){<br>　　alert("hello!")<br>}<br>上面第一行显示出来的结果是：<br>function func(){<br>&nbsp;&nbsp; &nbsp;alert("this is a function");<br>}<br>在预编译的情况下，它覆盖了第一个变量func<br>但是如果再添加两行代码，像这样：<br>alert(func);<br>var func = "this is a variable";<br>function func(){<br>&nbsp;&nbsp; &nbsp;alert("this is a function");<br>}<br>alert(func);<br>alert(func());<br>最后2个alert的结果又不同了，第一个alert显示的是变量func的值，第二个alert出错；<br>这2个结果的解释参考的网站没有给出具体的解释，其中有指明说出是在执行过程中遇到了var重新赋值<br>为"this is a variable"，此时变量func覆盖了func方法，所以func方法已不存在。<br>还有一个情况，看下面的代码<br>alert(a);//undefined<br>a();//出错<br>var a = function(){<br>alert("aa");<br>}<br>a();//aa<br><br>alert(tt);//function tt(){alert('tt');}<br>tt();//tt<br>function tt(){alert('tt');}<br>上面的代码中根据个人理解，用var定义变量并赋值一个function方法，和用function直接定义function<br>方法在预编译过程中显式出不同的结果，其中用var定义的a在预编译的时候只是分配了空间但不没有赋<br>值，所以第一个结果为undefined，第二个方法，由于var变量a在预编译时只被声明，并未赋值，故出现<br>错误提示，至于tt方法，应该比较好理解了